{
  "Id": "7B07B5DE-DF94-4DF5-B4AB-55EB46D51005",
  "Name": "Windows Install Updates",
  "Description": "Installs windows update and reboots until there is an error or the updates are all finished.\n\nRequires Installation of the PSWindowsUpdate module on the server and target machines.",
  "ActionType": "Octopus.Script",
  "Version": 19,
  "CommunityActionTemplateId": null,
  "Properties": {
    "Octopus.Action.Script.Syntax": "PowerShell",
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.RunOnServer": "false",
    "Octopus.Action.Script.ScriptBody": "Import-Module PSWindowsUpdate\n$octoClientDll = Join-Path $OctopusAgentProgramDirectoryPath 'Octopus.Client.dll'\n$server = $OctopusWebBaseUrl \n$apiKey = $OctopusApiKey  \n$computerName = $OctopusMachineName\n\nif(!$executionType){\n    throw \"Execution type is not defined\"\n}\n\nAdd-Type -Path $octoClientDll\n#Shim to help powershell call into a generic function\nAdd-Type -ReferencedAssemblies @($octoClientDll) -TypeDefinition @\"\npublic class OctoHelper\n{\n    public static Octopus.Client.Model.TaskResource GetTask(Octopus.Client.IOctopusClient client, string path)\n    {\n        return client.Get<Octopus.Client.Model.TaskResource>(path);\n    }\n}\n\"@\n\n$endpoint = New-Object Octopus.Client.OctopusServerEndpoint($server, $apiKey)\n$repository = New-Object Octopus.Client.OctopusRepository($endpoint)\n\n$machine = $repository.Machines.FindOne({param($m) $m.Name -eq $computerName})\nif(-not ($machine.Id)){\n    throw \"Could not find machine with name $computerName\"\n}\n\n$computerHostname = ([System.Uri]$machine.Uri).Host\nif(-not $computerHostname){\n    throw \"Could not find machine hostname\"\n}\n\nif($env:COMPUTERNAME -eq $computerHostname){\n    throw @\"\nThis task must not run on the target machine for upates, or Octopus will not be able to execute concurrently.\nConsider changing the execution plan to Run on \"Octopus Server\" on behalf of target clients.\n\"@\n}\n\n<# Running as a step would be best given that we have access to a full powershell environment and can run Get-WUInstall directly\nHowever AdHoc scripts in Octopus run in sequence even when on different machines.  This can be very slow in a multi machine install\nUntil Octopus changes this behaviour, this could be limiting.#>\nfunction Run-AsStep(){\n    $updateScript = @\"   \n    Write-Host `$env:ComputerName\n\n    if(([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] \"Administrator\")){\n        Write-Host \"Running as administrator.\"\n    }\n    \n    Import-Module PSWindowsUpdate\n    \n    Write-Host \"Checking for Windows Updates\"\n\n    if(PSWindowsUpdate\\Get-WUInstallerStatus -Silent){\n        Write-Host \"Windows installer is busy, waiting...\"\n    }\n\n    while(PSWindowsUpdate\\Get-WUInstallerStatus -Silent){\n        Start-Sleep -s 10\n    }\n\n    PSWindowsUpdate\\Get-WUInstall –AcceptAll -IgnoreReboot -IgnoreUserInput $PSWindowsUpdateParameters\n\n\"@\n    \n    $task = New-Object Octopus.Client.Model.TaskResource\n    $task.Name = \"AdHocScript\"\n    $task.Description = \"Windows Updates $computerHostname\"\n    $task.Arguments.Add(\"Syntax\", \"PowerShell\")\n    $task.Arguments.Add(\"MachineIds\", [string[]]@($machine.Id)) # //Your machine ID\n    \n    $task.Arguments.Add(\"ScriptBody\", $updateScript) \n    \n    $script:lastLog = [System.DateTimeOffset]::MinValue\n    $script:updatesStatus = @{}\n\n    [Action[Octopus.Client.Model.TaskResource[]]]$waitAction = {\n        param($tr) \n        \n        $td = $repository.Tasks.GetDetails($tr[0])\n        if($td){\n            $ll = $script:lastLog\n            $td.ActivityLogs[0].Children[0].LogElements | Where-Object {$_.OccurredAt -gt $ll} | %{\n\t\t\t\tif($_.MessageText -match \"^(?<id>\\d+)\\s+(?<status>[^\\s]+)\\s+(?<kb>[^\\s]+)\"){\n\t\t\t\t\t$id = $Matches[\"id\"]\n\t\t\t\t\t$status = $Matches[\"status\"]\n\t\t\t\t\t$kb = $Matches[\"kb\"]\n\t\t\t\t\t\n\t\t\t\t\t$script:updatesStatus[$kb] = $status\n\t\t\t\t}\n                \n                if($_.Category -eq \"Warning\"){\n                    $Host.UI.WriteWarningLine($_.MessageText)\n                }\n                elseif($_.Category -eq \"Error\"){\n                    $Host.UI.WriteErrorLine($_.MessageText)\n                    #Using a Host write because a Write-Error will output the stack trace for every line\n                }\n                else{\n                    $Host.UI.WriteLine($_.MessageText)\n                }\n                $script:lastLog = $_.OccurredAt\n            }\n        }\n    }\n    \n    $task = $repository.Tasks.Create($task)\n\n    Write-Host \"Running task $($task.Description) on $computerName $server$($task.Link(\"Web\"))\"\n\n    $repository.Tasks.WaitForCompletion($task, 10, 0, $waitAction) \n\n    $task = [OctoHelper]::GetTask($repository.Tasks.Client, $task.Link(\"Self\"))\n\n    if($task.State -eq [Octopus.Client.Model.TaskState]::Failed){\n        throw \"Task Failed: $($task.ErrorMessage)\"\n    }\n    else{\n        Write-Host \"Task complete\"\n    }\n\n    return $script:updatesStatus\n}\n\nfunction Invoke-WUPsRemote{\n    param($computerHostname, $PSWindowsUpdateParameters)\n    \n    Write-Host \"Running remote script on $computerHostname\"\n    \n    $scriptCurrentTaskOuput = [ScriptBlock]{\n        #There is a Get-ScheduledTask command but it doesn't work < NT 6.2\n        Function Get-PSWindowsUpdateTask{\n            [CmdletBinding()]\n            param()\n        \ttry{\n\t\t\t    $scheduler = New-Object -ComObject Schedule.Service\n        \t    $scheduler.Connect($env:COMPUTERNAME)\n        \t    $rootFolder = $scheduler.GetFolder(\"\\\")\n        \t    $task = $rootFolder.GetTask(\"PSWindowsUpdate\")\n        \t}\n\t\t\tcatch{\n\t\t\t\tWrite-Error \"Error getting task PSWindowsUpdate: $($_.Exception)\"\n\t\t\t}\n\n        \tif($task){\n        \t\t[PSCustomObject]@{\n        \t\t\tActions = $task.Definition.Actions | % { [PSCustomObject]@{ Id = $_.Id; Execute = $_.Path; Arguments = $_.Arguments} }\n        \t\t\tTaskName = $task.Name\t\t\t\n        \t\t\tState = if($task.State -eq 1){\"Disabled\"}\n        \t\t\t\t\telseif($task.State -eq 2){\"Queued\"}\n        \t\t\t\t\telseif($task.State -eq 3){\"Ready\"}\n        \t\t\t\t\telseif($task.State -eq 4){\"Running\"}\n        \t\t\t\t\telse{\"Unknown\"}\n        \t\t\tLastTaskResult = $task.LastTaskResult\n        \t\t}\n        \t}\n        }\n\n\t\tif(-not (Get-Module PSWindowsUpdate -ListAvailable)){\n\t\t\tthrow \"PSWindowsUpdate module must be installed on the remote system.\"\n\t\t}\n\n        $tsk = Get-PSWindowsUpdateTask -ErrorAction SilentlyContinue\n        if($tsk -and ($tsk.State -eq \"Running\")){\n            if($tsk.Actions.Arguments -match \"Out-File\\s\"\"(?<file>[^\"\"]+)\"\"\"){\n                $matches[\"file\"]\n            }\n        }\n    }\n    \n    $tmpOutput = Invoke-Command -ComputerName $computerHostname -ScriptBlock $scriptCurrentTaskOuput\n    \n    #the task is not currently running\n    if(-not $tmpOutput){\n        $tmpOutput = Invoke-Command -ComputerName $computerHostname -ScriptBlock { [System.IO.Path]::GetTempFileName() }\n            \n        Write-Host \"Starting windows update scheduled task.\"\n    \n        $scriptUpd = \"ipmo PSWindowsUpdate; Get-WUInstall -AcceptAll -IgnoreReboot -IgnoreUserInput $PSWindowsUpdateParameters | Out-File \"\"$tmpOutput\"\"\"\n    \n        PSWindowsUpdate\\Invoke-WUInstall -TaskName PSWindowsUpdate -Confirm:$false -ComputerName $computerHostname -Script ([Scriptblock]::Create($scriptUpd)) \n    }\n    else{\n        Write-Host \"Windows update scheduled task already running.\"\n    }\n\n    #Wait for the task to finish and read the log output as it progresses\n    Invoke-Command -ComputerName $computerHostname -ArgumentList $tmpOutput -ScriptBlock {\n        param($tmpOutput)\n        \n        #There is a Get-ScheduledTask command but it doesn't work < NT 6.2\n        Function Get-PSWindowsUpdateTask{\n            [CmdletBinding()]\n            param()\n        \ttry{\n\t\t\t    $scheduler = New-Object -ComObject Schedule.Service\n        \t    $scheduler.Connect($env:COMPUTERNAME)\n        \t    $rootFolder = $scheduler.GetFolder(\"\\\")\n        \t    $task = $rootFolder.GetTask(\"PSWindowsUpdate\")\n        \t}\n\t\t\tcatch{\n\t\t\t\tWrite-Error \"Error getting task PSWindowsUpdate: $($_.Exception)\"\n\t\t\t}\n\n        \tif($task){\n        \t\t[PSCustomObject]@{\n        \t\t\tActions = $task.Definition.Actions | % { [PSCustomObject]@{ Id = $_.Id; Execute = $_.Path; Arguments = $_.Arguments} }\n        \t\t\tTaskName = $task.Name\t\t\t\n        \t\t\tState = if($task.State -eq 1){\"Disabled\"}\n        \t\t\t\t\telseif($task.State -eq 2){\"Queued\"}\n        \t\t\t\t\telseif($task.State -eq 3){\"Ready\"}\n        \t\t\t\t\telseif($task.State -eq 4){\"Running\"}\n        \t\t\t\t\telse{\"Unknown\"}\n        \t\t\tLastTaskResult = $task.LastTaskResult\n        \t\t}\n        \t}\n        }\n        \n        Write-Host \"Reading logs from $tmpOutput\"\n        \n\t\t$updatesCount = 0\n\t\t$downloadedCount = 0\n\t\t$installedCount = 0\n\t\t$updatesStatus = @{}\n\t\tWrite-Progress -Activity \"Windows Updates\" -Status \"Getting Updates...\"\n\t\t\n        #Read the file file as it is being written.\n        #We could use a Get-Content -Wait but it is unreliable, sometimes it just does NOT pick up on file changes\n        $linesRead = 0\n        $finished = $false\n        while(-not $finished){\n            $tsk = Get-PSWindowsUpdateTask -ErrorAction $ErrorActionPreference\n                \n            $finished = $tsk.State -eq \"Ready\"\n                \n            $logContent = Get-Content $tmpOutput\n            $lineCount = $logContent.Count\n            if($lineCount -gt $linesRead){\n                $logContent[$linesRead..$lineCount] | %{\n\t\t\t\t\tif($_ -match \"^(?<id>\\d+)\\s+(?<status>[^\\s]+)\\s+(?<kb>[^\\s]+)\"){\n\t\t\t\t\t\t$id = $Matches[\"id\"]\n\t\t\t\t\t\t$status = $Matches[\"status\"]\n\t\t\t\t\t\t$kb = $Matches[\"kb\"]\n\n\t\t\t\t\t\tif($id -eq \"2\"){\n\t\t\t\t\t\t\t$updatesCount++\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif($id -eq \"3\"){\n\t\t\t\t\t\t\t$downloadedCount++\n\t\t\t\t\t\t\tWrite-Progress -Activity \"Windows Updates\" -Status \"Downloading Updates\" -PercentComplete (($downloadedCount / $updatesCount) * 100)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif($id -eq \"4\"){\n\t\t\t\t\t\t\t$installedCount++\n\t\t\t\t\t\t\tWrite-Progress -Activity \"Windows Updates\" -Status \"Installing Updates\" -PercentComplete (($installedCount/ $updatesCount) * 100)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$updatesStatus[$kb] = $status\n\n\t\t\t\t\t\tif(($status -eq \"Failed\") -or ($status -eq \"Aborted\")){\n\t\t\t\t\t\t\tWrite-Warning $_\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tWrite-Host $_\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tWrite-Host $_\n\t\t\t\t\t}\n\t\t\t\t}\n                $linesRead = $lineCount\n            }\n            if(-not $finished){\n                Start-Sleep -s 10\n            }\n        }\n          \n\t\tWrite-Progress -Activity \"Windows Updates\" -Completed -Status \"All Done\"\n\t\t\t\t     \n        if($tsk.LastTaskResult -ne 0){\n            throw \"PSWindowsUpdate task failed with error $($tsk.LastTaskResult)\"\n        }\n\n\t\treturn $updatesStatus\n    }\n    \n    <#\n    If we are having trouble with permissions we can try moving to a Powershell session configuration name\n    This allows for better impersonation of a user but requires more permissions ahead of time.\n    However even using a session configuration configured as an administrator will no allow us to use the Get-WUInstall directly, it will still error out\n    \n    Using a session configuration would also probably require rewriting the Invoke-WUInstall script as it does not have a paramter for a session configuration\n    \n    https://technet.microsoft.com/en-us/library/dd819496.aspx\n    https://blogs.msdn.microsoft.com/taylorb/2012/03/26/remote-administration-with-powershell-3-0-sessions-part-1/\n    \n    $PSSessionConfiguration = if($PSSessionConfiguration) {$PSSessionConfiguration} elseif($PSSessionConfigurationName){$PSSessionConfigurationName} else {\"Microsoft.PowerShell\"}\n    \n    $session = New-PSSession -ComputerName $computerHostname -ConfigurationName $PSSessionConfiguration\n    \n    #>\n\n    Write-Host \"Finished remote script\"\n}\n\n$totalInstalled = 0\n$reboots = 0\n$failedUpdates = @{}\n$startDT = Get-Date\n$complete = $false\nwhile(-not $complete){\n\n    if($executionType -eq \"Octopus Task\"){\n        $updatesStatus = Run-AsStep\n    }\n    elseif($executionType -eq \"PS Remote\"){\n        $updatesStatus = Invoke-WUPsRemote -ComputerHostName $computerHostname -PSWindowsUpdateParameters $PSWindowsUpdateParameters\n    }\n    else{\n        throw \"Unknown execution type $executionType\"\n    }\n\n\tif($updatesStatus -and ($updatesStatus.Count -gt 0)){   \n\t\t$updatesStatus = $updatesStatus.Keys | %{ [PSCustomObject]@{ KB = $_; Status = $updatesStatus[$_] } }\n\t\t\n\t\t$updatesStatus | Group-Object Status\n\t\t\n\t\t$totalInstalled = $totalInstalled + ($updatesStatus | ?{$_.Status -eq \"Installed\"}).Count\n\t\t\n\t\t$updatesStatus | ?{$_.Status -eq \"Failed\"} | %{\n\t\t\t$failedUpdates[$_.KB] = $failedUpdates[$_.KB] + 1\n\t\t\tif($failedUpdates[$_.KB] -gt $MaxFailRetries){\n\t\t\t\tthrow \"Update $($_.KB) has failed more than $MaxFailRetries times. Aborting installation.\"\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tWrite-Host \"No updates found.\"\n\t}\n\t\n    if(PSWindowsUpdate\\Get-WURebootStatus -Silent -ComputerName $computerHostname)\n    {\n        Write-Host \"Reboot requried, rebooting $computerHostname\"\n        Restart-Computer -ComputerName $computerHostname -Force -Wait -Timeout $RebootTimeout -For WinRM\n        \n        if($executionType -eq \"Octopus Task\"){\n            $octoService = $false\n            Write-Host \"Waiting for octopus service\"\n            while(-not $octoService){\n                #sometimes get service fails because the machine is not ready for the call yet\n                $octoService = Get-Service -ComputerName $computerHostname -Name \"OctopusDeploy Tentacle\" -ErrorAction SilentlyContinue\n                if(-not $octoService){\n                    Start-Sleep -s 10\n                }\n            }\n            \n            $octoService.WaitForStatus([System.ServiceProcess.ServiceControllerStatus]::Running)\n        }\n        \n        $reboots++\n    }\n    elseif(-not $updatesStatus -or ($updatesStatus.Count -eq 0))\n    {\n\t\t$runTime = ((Get-Date) - $startDT) | %{ \"$([Math]::Floor($_.TotalHours)) hours $($_.Minutes) minutes $($_.Seconds) seconds\" }\n\t\tWrite-Host \"$totalInstalled updates completed in $runTime, requiring $reboots reboots.\"\n        $complete = $true\n    }\n}\n",
    "Octopus.Action.Script.ScriptFileName": null,
    "Octopus.Action.Package.FeedId": null,
    "Octopus.Action.Package.PackageId": null
  },
  "Parameters": [
    {
      "Id": "6157158d-48eb-44a8-bbe1-b264732c8dd8",
      "Name": "ExecutionType",
      "Type": "String",
      "Label": "Execution Type",
      "HelpText": "How to perform the updates on the remote machine.\n\nPS Remote may require more configuration on your network as machines need to be set up to allow for remote powershell sessions.\n\nOctopus Task requires that a tentacle be installed on each machine. Octopus also does not allow adhoc tasks to be run in parallel, greatly increasing the run time if using task.",
      "DefaultValue": "PS Remote",
      "DisplaySettings": {
        "Octopus.ControlType": "Select",
        "Octopus.SelectOptions": "Octopus Task\nPS Remote"
      },
      "Links": {}
    },
    {
      "Id": "a09eab31-efbf-4fcb-8ffe-08f227fc5fbd",
      "Name": "PSWindowsUpdateParameters",
      "Type": "String",
      "Label": "Windows Update Parameters",
      "HelpText": "Additional parameters passed to the Get-WUInstall command executed on the client to install windows updates.\n\nParameters already passed are...\n–AcceptAll -IgnoreReboot -IgnoreUserInput\n\nSome options include...\n\n(-UpdateType) \nPre search criteria. Finds updates of a specific type, such as 'Driver' and 'Software'. Default value contains all updates. \n\n(-UpdateID) \nPre search criteria. Finds updates of a specific UUID (or sets of UUIDs), such as '12345678-9abc-def0-1234-56789abcdef0'. \n\n(-RevisionNumber) \nPre search criteria. Finds updates of a specific RevisionNumber, such as '100'. This criterion must be combined with the UpdateID param. \n\n(-Category) \nPost search criteria. Finds updates that contain a specified category name (or sets of categories name), such as 'Updates', 'Security Updates', 'Critical Updates', etc... \n\n(-KBArticleID )\nPost search criteria. Finds updates that contain a KBArticleID (or sets of KBArticleIDs), such as 'KB982861'. \n\nFor more options go to https://www.powershellgallery.com/packages/PSWindowsUpdate/1.5.2.2/Content/Get-WUInstall.ps1",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "e7fb0bfe-3476-49c4-94ff-7d94693f2399",
      "Name": "OctopusApiKey",
      "Type": "Sensitive",
      "Label": "Octopus API Key",
      "HelpText": "(If using execution type = Octopus Task)The step needs to be able to generate tasks on the octopus server.  To do this it needs an API key.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "15be1d1b-533c-46f0-bf4e-1bd3bea0dce2",
      "Name": "MaxFailRetries",
      "Type": "String",
      "Label": "Max Fail Retries",
      "HelpText": "Maximum times to retry a failed update",
      "DefaultValue": "3",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "5a67062e-e06e-4740-87bf-83802f7f1f92",
      "Name": "RebootTimeout",
      "Type": "String",
      "Label": "Reboot Timeout",
      "HelpText": "Maximum time in seconds to wait for a computer to reboot after installing updates.",
      "DefaultValue": "-1",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    }
  ],
  "$Meta": {
    "ExportedAt": "2017-06-13T14:57:30.036Z",
    "OctopusVersion": "3.11.7",
    "Type": "ActionTemplate"
  }
}